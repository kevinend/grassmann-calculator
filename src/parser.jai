/*
    The parser is based off this algorithm https://github.com/erikeidt/erikeidt.github.io/blob/master/The-Double-E-Method.md.
    The first implementation was a hand-rolled recursive descent parser then a pratt parser and a combo of
    a shunting yard to convert expressions to RPN then recursive descent. The chosen method leverages two stacks so the recursion
    of normal algorithms is replaced with a simple top level loop.

    On Error Reporting:

    Error messages are handled in two phases. Phase 1 occurs parsing where obvious syntatic mistakes have been made.
    Examples include unmatched parenthesis or two identifiers next to each other without an infix operator, etc. Phase 2
    is a pass over the constructed AST to investigate semantic errors. These are things like performing scalar operations
    between two basis elements (which is not defined), assigning an expression to a scalar symbol, or making a function
    call with an unrecognized intrinsic, undefined symbols (using a symbol prior to it's definition), etc..

*/

#scope_export

Parser :: struct {

    tokens: [] Token;
    current_token: int;

    mode:       Mode;
    operators:  Stack(Operator);
    operands:   Stack(*Ast_Node);

    // metadata for each node generated by the parser.
    node_id: u16;
    position_metadata: [..] Position_Info;

    error_detected: bool;
    error_message:  string;
}


parse :: (parser: *Parser, tokens: [] Token) -> bool #must, Ast {

    ast: Ast;
    success: bool;
    reset_parser(parser, tokens);

    parser_context := context;
    parser_context.allocator = temp;
    push_context parser_context {
        success, ast = parse_expression(parser);
    }

    return success, ast;
}

get_parser_error :: (parser: *Parser) -> string {
	return parser.error_message;
}

descend :: (node: *Ast_Node, indent: int = 0) {

    // Utility function to print AST's until the interpreter is up and working!
    if node == null {
        return;
    }

    for i: 0..indent-1 {
		print( " " );
	}

    if node.kind == .Error {
        error := cast(*Error_Node)node;
        print("(%) Error Node == %\n", error.node_id, error.message);
    }
    else
    if node.kind == .Unary_Operator {
        operator_node := cast(*Unary_Operator_Node)node;
        print("(%) Unary operator == %\n", operator_node.node_id, operator_node.op);
        descend(operator_node.rhs, indent + 2);
    }
    else
    if node.kind == .Identifier {
        identifier := cast(*Identifier_Node)node;
        print("(%) Identifier == %\n", identifier.node_id, identifier.name);
    }
    else
    if node.kind == .Variable {
        var := cast(*Variable_Node)node;
        print("(%) Variable == %\n", var.node_id, var.name);
    }
    else
    if node.kind == .Element {
        element := cast(*Element_Node)node;
        print(
			"(%) Element (Coefficient=%, Grade=%, Symbol=%, Bits=%)\n"
            ,element.node_id
            ,coefficient_to_string(element.coefficient)
            ,element.basis.grade
            ,element.basis.symbol
            ,element.basis.bits
		);
    }
    else
    if node.kind == .Binary_Operator {
        binary_operator := cast(*Binary_Operator_Node)node;
        print("(%) Binary Operator == %\n", binary_operator.node_id, binary_operator.op );
        descend(binary_operator.lhs, indent + 2);
        descend(binary_operator.rhs, indent + 2);
    }
    else
    if node.kind == .Intrinsic {
        intrinsic := cast(*Intrinsic_Node)node;
        if intrinsic.type == {
            case .Direction; { print("(%) Intrinsic: Direction\n", intrinsic.node_id); }
            case .Position;  { print("(%) Intrinsic: Position\n",  intrinsic.node_id); }
            case .Basis;     { print("(%) Intrinsic: Basis\n",     intrinsic.node_id); }
        }
    }
}

#scope_file

Mode :: enum u8 {
    Prefix;
    Infix_or_Postfix;
}

reset_parser :: (parser: *Parser, tokens: [] Token) {

    parser.tokens = tokens;
    parser.current_token = 0;

    parser.mode = .Prefix;

    parser.node_id = 0;
    array_reset(*parser.position_metadata);

    parser.error_detected = false;
}

flag_error :: (parser: *Parser, position: Position_Info, message: string) {

    line_number := position.line_number;
	char_start  := position.char_start;

	base := tprint("Parse Error! Line:%, Char:% -- ", line_number, char_start);

	builder: String_Builder;
	builder.allocator = temp;

	append(*builder, base);
	append(*builder, message);
    append(*builder, "\n");

	parser.error_detected = true;
	parser.error_message  = builder_to_string(*builder);
}

parse_expression :: (parser: *Parser) -> bool, Ast {

    using parser;

    while true {
        token := consume_token(parser);
        if token.type == .Semicolon || parser.error_detected { break; }

        if parser.mode == .Prefix {
            op := attempt_to_convert_token_to_prefix_operator(token);
            if is_operator(op) {
                stack_push(*operators, op);
            }
            else {
                operand := new_operand(parser, token);
                stack_push(*operands, operand);
                parser.mode = .Infix_or_Postfix;
            }
        }
        else
        if parser.mode == .Infix_or_Postfix {
            op := attempt_to_convert_token_to_infix_or_postfix_operator(token);
            if !is_operator(op) {
                flag_error(parser, token.position, "Expected a postfix operator after prior operand or an infix operator before this operands.");
                continue;
            }

            if op.type == .Right_Complement {
                // Post-fix operator that needs to stay infix or postfix mode since not expecting another prefix operator or operand.
                apply_operators_with_greater_precedence_then_push(parser, op);
                continue;
            }

            if op.type == .Group_End {
                apply_operators_until_group_start(parser);
            }
            else {
                // Apply operators with higher precedence than our current operator.
                // Once complete the operator stack is either empty or our operator has a higher precedence then the current head of the stack.
                // In either case, make our operator the new head of the operators stack.
                apply_operators_with_greater_precedence_then_push(parser, op);
                parser.mode = .Prefix;
            }
        }
    }

    ast: Ast;
    ast.root = apply_remaining_operators(parser);
    ast.position_metadata = position_metadata;

    return !parser.error_detected, ast;
}

peek_token :: (parser: *Parser) -> Token {
    token := parser.tokens[parser.current_token];
    return token;
}

consume_token :: (parser: *Parser) -> Token {
    token := parser.tokens[parser.current_token];
    parser.current_token += 1;
    return token;
}

new_operand :: (parser: *Parser, token: Token) -> *Ast_Node {

    // Generate a new operand node by converting the token into its respective AST node type.

    using parser;

    node: *Ast_Node = null;
    array_add(*position_metadata, token.position);

    if token.type == .Number {
        coefficient := new_term(token.value);
        basis       := get_basis_element(0);

        node = new_element_node(node_id, coefficient, basis);
    }
    else
    if token.type == .Identifier {
        node = new_identifier_node(node_id, token.text);
    }
    else
    if token.type == .Keyword_Direction {
        node = new_intrinsic_node(node_id, .Direction);
    }
    else
    if token.type == .Keyword_Position {
        node = new_intrinsic_node(node_id, .Position);
    }
    else
    if token.type == .Keyword_Basis {
        node = new_intrinsic_node(node_id, .Basis);
    }
    else
    if token.type == .Error {
        node = new_error_node(node_id, token.text);
    }

    node_id += 1;
    
    return node;
}

apply_operator :: (parser: *Parser, op: Operator) -> *Ast_Node {

    // Apply the operator by constructing the operator node using the required number of operands and push the new node on the *operand* stack.

    using parser;

    node: *Ast_Node = null;
    array_add(*position_metadata, op.position);

    if get_operator_arity(op) == {
        case 1; {
            rhs := stack_pop(*operands);
            node = new_unary_operator_node(node_id, op.type, rhs);
        }
        case 2; {
            rhs := stack_pop(*operands);
            lhs := stack_pop(*operands);
            node = new_binary_operator_node(node_id, lhs, op.type, rhs);
        }
        case; {
            message := tprint("Unable to construct operator node. Unknown arity for operator '%'.", op.type);
            flag_error(parser, op.position, message);
        }
    }

    node_id += 1;

    return node;
}

apply_operators_until_group_start :: (parser: *Parser) {

    // Build new operand nodes with the operator at the head of the stack until we reach either .Group_Start or .Function_Call.
    // If we reach the end of the stack before finding a match then the expression has an unmatched open parenthesis.

    using parser;

    while !stack_is_empty(operators) {
        op := stack_pop(*operators);
        if op.type == {
            case .Group_Start; { return; }
            case .Function_Call; {
                // Function call can either be of the form 'functionName(arg1)' or 'functionName(arg1,arg2,arg3,..)
                // In each case the Function Call is a binary operator whose lhs is the function name and the rhs depends on the cases above.
                //  (1) Single arg will have the rhs of the binary operator node for the function call be 'arg1'
                //  (2) Multi-arg  will have the rhs of the binary operator node for the function call be another binary operator of type 'Function_Argument_Separator'
                //      whose lhs and rhs are either the args or another 'Function_Argument_Separator' containing more arguments of the function. Rinse and repeat for all the args in the function call.
                operand := apply_operator(parser, op);
                stack_push(*operands, operand);
                return;
            }
        }

        operand := apply_operator(parser, op);
        stack_push(*operands, operand);
    }

    /* TODO: Report error in the parser!
    message := tprint("Unmatched closing paranthesis in expression.");
    error   := new_error_node(node_id, message);
    stack_push(*operands, error);
    */

    return;
}

apply_operators_with_greater_precedence_then_push :: (parser: *Parser, op: Operator) {

    // Build new operand nodes using the operator at the head of the stack while it has a higher precedence than the currently parsed operator.
    using parser;

    op_precedence := get_operator_precedence(op);
    while !stack_is_empty(operators) {
        head_op            := stack_peek(operators);
        head_op_precedence := get_operator_precedence(head_op);

        // While parsing a function call or grouping/subexpression () we want to continue to push operators and operands within the group until we hit the closing paren.
        // Operators within the grouping symbols should follow the standard rules of comparing operator precedence and applying in their defined order. However, we want
        // to skip the comparisons of any infix or postfix operators with the grouping symbols themselves in the operator stack. Once we hit the closing paren
        // we apply the pushed operators building the appropriate Ast using our other application function.

        if head_op.type == {
            case .Function_Call;               { break; }
            case .Function_Argument_Separator; { break; }
            case .Group_Start;                 { break; }
        }

        if head_op_precedence > op_precedence {
            head_op  = stack_pop(*operators);

            operand := apply_operator(parser, head_op);
            stack_push(*operands, operand);
        }
        else { break; }
    }

    stack_push(*operators, op);
    return;
}

apply_remaining_operators :: (parser: *Parser) -> *Ast_Node {

    // Apply the remaining operators left on the stack returning the AST as the last operand node on successful parse.
    using parser;

    while !stack_is_empty(operators) {
        op := stack_pop(*operators);
        if op.type == .Group_Start || op.type == .Function_Call {
            /* TODO: This is a parser error and should be reported as such!
            message := tprint("Unmatched parentheses found in expression.");
            error   := new_error_node(node_id, message);
            stack_push(operands, error);
            */

            break;
        }

        // TODO: Robustness here!
        // "e1-" this will be parsed as the infix operator subtraction but missing the rhs operand.
        // We'd need to check the arity to make sure it requires two arguments then report that it is missing the rhs.
        operand := apply_operator(parser, op);
        stack_push(*operands, operand);
    }

    return stack_pop(*operands);
}