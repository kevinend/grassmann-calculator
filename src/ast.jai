#scope_export

/* 
    This file declares the Abstract Syntax Tree nodes generated by the parser and updated by the multiple
    passes over the AST.


    On Operator Nodes:

    Operators are rolled up/categorized into either a unary or binary operator node.
    This roll-up reduces the overall number of AST node types but introduces additional computational
    overhead. Specifically, once you encounter a binary operator node in the AST you need to dispatch
    on the operator type whereas if you had a 'Addition' node this extra step would be unnecessary.

    The primary benefit to structuring operators into these categories is that it keeps the number of
    AST node types low. We could do 1-to-1 operator to node type but that would require a bunch of
    new nodes and changes to the parser away from the simple notion of arity for an operator.


    On Scalar Node Types:

    In Grassmann algebra the field of scalars for the Exterior space are considered grade-0 elements.
    Grade-0 objects are *not* represented as basis elements in this application but rather handled separately in their own AST node types.
    The application needs to handle the following cases: 
        1. 3 + 4       = 7          ; sum of individual scalars
        2. 3e1 + 4e1   = 7e1        ; sum of scalar coefficients of basis elements
        3. 3 + a1      = 3 + a1     ; sum of a scalar (value) and a scalar symbol
        4. a1 + b2     = a1 + b2    ; sum of a scalar symbol and another scalar symbol
        5. a1e1 + b2e1 = (a1+b2)e1  ; sum of a scalar symbol coefficients of basis elements

    These examples used addition but it applies to scalar multiplication as well.

    Two scalar node types are introduced to handle all these cases; 'Scalar_Node' and 'Scalar_Expression'.
    Cases (1) and (2) use the basic Scalar_Node type which minimizes wasted memory and is dead simple to calculate addition and multiplication.

    Cases (3), (4) and (5) use the Scalar_Expression node type. This node view creates a list of terms where each term contains a list of scalar
    factors. Obviously the memory usage is much more substantial (especially when the list of terms or factors is sparse) and the resulting calculations
    for addition and multiplication require nested loops. The waste felt substantial enough to split these cases into two unique representations.

 
    On the Scalar Type's 'symbol' field:

    A scalar can either be a value like 3 or a symbol like 'a1'. The 'Scalar' type has a field called 'symbol' which is defined 
    to be either "1" (for values) or a single leading character followed by up to 3 digits (ex. a1, a01, a001, A1, etc.).

    Instead of the symbol field being a string or a pointer to an interned string the symbol is encoded as a u16.
    That u16 is stored in a hashtable that uses the u16 as a key and returns the string representation of the symbol
    when we need to print the scalar to the end-user. All calculations use the u16 representation.

    For some reason using a 16-byte string, or an 8-byte pointer to a string seemed too wasteful when the symbol can
    be easily encoded into a 2-byte short. Currently the scalar type is 16 bytes but could be scaled down to 8 if the value
    and exponent types are further constrained but that seemed unnecessary at this time.
*/

Node_Kind :: enum u8 {
    Numeric_Literal;
    Symbol;
    Basis_Element;
    Scalar;        
    Scalar_Expression;
    Unary_Operator;     // prefix operators
    Binary_Operator;    // infix/postfix operators
    Intrinsic;
}

Ast_Node :: struct {
    kind: Node_Kind;
}

Ast :: struct {
    root: *Ast_Node;
}

Numeric_Literal_Node :: struct {
    #as using _kind: Ast_Node;
    value: int;
}

Symbol_Node :: struct {
    #as using _kind: Ast_Node;
    name: string;
}

Basis_Element_Node :: struct {
    #as using _kind: Ast_Node;
	
	coefficient: *Ast_Node;	        // scalar or scalar expression
	basis:       *Basis_Element;
}

Scalar :: struct {
    value:    int;
    exponent: s16;
    symbol:   u16;
}

Scalar_Node :: struct {
    #as using _kind: Ast_Node;
    using scalar: Scalar;
}

Term :: struct {
    multiples: int;
    factors: [..] Scalar;
}

Scalar_Expression_Node :: struct {
    #as using _kind: Ast_Node;
    terms: [..] Term;
}

Unary_Operator_Node :: struct {
    #as using _kind: Ast_Node;
    op:  Operator;
    rhs: *Ast_Node;
}

Binary_Operator_Node :: struct {
    #as using _kind: Ast_Node;
    lhs: *Ast_Node;
    op:  Operator;
    rhs: *Ast_Node;
}

// Keywords get mapped to intrinsic node types.
// Intrsics are predefined functions/commands that user's can call within an expression.
Intrinsic_Type :: enum u8 {
    Direction;
    Position;
    Basis;
}

Intrinsic_Node :: struct {
    #as using _kind: Ast_Node;
    type: Intrinsic_Type;
}

new_numeric_literal_node :: (value: int) -> *Ast_Node {

    node: *Numeric_Literal_Node = alloc(size_of(Numeric_Literal_Node));
    assert(node != null);

    node.kind = Node_Kind.Numeric_Literal;
    node.value = value;
    return node;
}

new_symbol_node :: (name: string) -> *Ast_Node {

    node: *Symbol_Node = alloc(size_of(Symbol_Node));
    assert(node != null);

    node.kind = Node_Kind.Symbol;
    node.name = name;
    return node;
}

new_basis_element_node :: (coefficient: *Scalar_Node, basis_element: *Basis_Element) -> *Ast_Node {

    node: *Basis_Element_Node = alloc(size_of(Basis_Element_Node));
    assert(node != null);

    node.kind        = Node_Kind.Basis_Element;
    node.coefficient = coefficient;
    node.basis       = basis_element;

    return node;
}

new_scalar_node :: (value: int, symbol: string) -> *Ast_Node {

    node: *Scalar_Node = alloc(size_of(Scalar_Node));
    assert(node != null);

    node.kind = Node_Kind.Scalar;
    node.value    = value;
    node.exponent = 1;
    node.symbol   = encode_scalar(symbol);

    // update_symbol_table(*symbol_table, key, value)
    // update_symbol_table(*symbol_table, node.symbol, symbol, scalars!);

    return node;
}

new_scalar_expression_node :: (factor: Scalar) -> *Ast_Node {

    node: *Scalar_Expression_Node = alloc(size_of(Scalar_Expression_Node));
    assert(node != null);

    // Takes a scalar, creates a term with that single factor and returns it.
    term: Term;
    term.multiples = 1;
    
    factors: [..] Scalar;
    terms:   [..] Term;

    array_add(*factors, factor);
    term.factors = factors;

    array_add(*terms, term);

    node.kind  = Node_Kind.Scalar_Expression;
    node.terms = terms;

    return node;
}

new_unary_operator_node :: (op: Operator, rhs: *Ast_Node) -> *Ast_Node {

    node: *Unary_Operator_Node = alloc(size_of(Unary_Operator_Node));
    if !node { print( "Error!\n" ); }

    node.kind = Node_Kind.Unary_Operator;
    node.op = op;
    node.rhs = rhs;

    return node;
}

new_binary_operator_node :: (lhs: *Ast_Node, op: Operator, rhs: *Ast_Node) -> *Ast_Node {

    node: *Binary_Operator_Node = alloc(size_of(Binary_Operator_Node));
    if !node { print("Error!\n" );}

    node.kind = Node_Kind.Binary_Operator;
    node.lhs = lhs;
    node.op = op;
    node.rhs = rhs;

    return node;
}

new_intrinsic_node :: (type: Intrinsic_Type) -> *Ast_Node {

    node: *Intrinsic_Node = alloc(size_of(Intrinsic_Node));
    if !node { print("Error!\n"); }

    node.kind = Node_Kind.Intrinsic;
    node.type = type;

    return node;
}

#scope_file

encode_scalar :: (s: string) -> u16 {

    // Format of a scalar symbol is an alphabet character followed by up to 3 digits
    // The smallest number is a000 and the largest is Z999.
    // We map a-z to the numbers 1-26 and A-Z as 26-53.
    // As long as we keep this range we can fit all the scalar symbols hashes into u16s.
    //
    // The hash value zero (0) is reserved for the symbol "1" which is used to represent pure numbers.
    //
    // To build up the number we start at end the end of the string and parse digits as powers of 10
    // then convert the character and add its value.

    assert(s[0] == #char "1" || (s[0] >= #char "a" && s[0] <= #char "z") || (s[0] >= #char "A" && s[0] <= #char "Z"));
    assert(s.count <= 4);

    if s[0] == #char "1" {
        return 1;
    }

    i := s.count-1;

    value:  u16;
    powers: u16 = 1;
    digit:  u16;
    while i > 0 {
        digit  = s[i] - #char "0";
        digit  *= powers;
        value  += digit;

        powers *= 10;
        
        i-= 1;
    }

    if s[0] >= #char "a" && s[0] <= #char "z" {
        digit  = s[i] - #char "a" + 1;
        digit *= powers;
        value += digit;
    }
    else {
        digit  = (s[i] - #char "A") + 27;
        digit *= powers;
        value += digit; 
    }

    assert( value <= 65535 );
    return value;
}