#scope_export

/*
    This file declares the Abstract Syntax Tree nodes generated by the parser and updated by the multiple passes over the AST.
*/

Node_Kind :: enum u8 {
    
    /*
        Operators are rolled up/categorized into either a unary or binary operator node.
        This roll-up reduces the overall number of AST node types but introduces additional computational
        overhead. Specifically, once you encounter a binary operator node in the AST you need to dispatch
        on the operator type whereas if you had a 'Addition' node this extra step would be unnecessary.

        The primary benefit to structuring operators into these categories is that it keeps the number of
        AST node types low. We could do 1-to-1 operator to node type but that would require a bunch of
        new nodes and changes to the parser away from the simple notion of arity for an operator.
    */

    Identifier;
    Variable;
    Element;            // element of an exterior space
    Unary_Operator;     // prefix operators
    Binary_Operator;    // infix/postfix operators
    Intrinsic;
}

Ast_Node :: struct {
    kind: Node_Kind;
}

Ast :: struct {
    root: *Ast_Node;
}

Identifier_Node :: struct {
    #as using _kind: Ast_Node;
    name: string;
}

Variable_Node :: struct {
    // Identifier nodes are converted to this node type during symbol resolution.
    #as using _kind: Ast_Node;
    name: string;
}

Element_Node :: struct {
    #as using _kind: Ast_Node;

	coefficient: *Term;
	basis:       *Basis_Element;
}

Unary_Operator_Node :: struct {
    #as using _kind: Ast_Node;
    op:  Operator;
    rhs: *Ast_Node;
}

Binary_Operator_Node :: struct {
    #as using _kind: Ast_Node;
    lhs: *Ast_Node;
    op:  Operator;
    rhs: *Ast_Node;
}

// Keywords get mapped to intrinsic node types.
// Intrsics are predefined functions/commands that user's can call within an expression.
Intrinsic_Type :: enum u8 {
    Direction;
    Position;
    Basis;
}

Intrinsic_Node :: struct {
    #as using _kind: Ast_Node;
    type: Intrinsic_Type;
}

new_identifier_node :: (name: string) -> *Ast_Node {

    node: *Identifier_Node = talloc(size_of(Identifier_Node));
    assert(node != null);

    node.kind = Node_Kind.Identifier;
    node.name = name;
    return node;
}

new_element_node :: (coefficient: *Term, basis_element: *Basis_Element) -> *Ast_Node {

    node: *Element_Node = talloc(size_of(Element_Node));
    assert(node != null);

    node.kind        = Node_Kind.Element;
    node.coefficient = coefficient;
    node.basis       = basis_element;

    return node;
}

new_unary_operator_node :: (op: Operator, rhs: *Ast_Node) -> *Ast_Node {

    node: *Unary_Operator_Node = talloc(size_of(Unary_Operator_Node));
    if !node { print( "Error!\n" ); }

    node.kind = Node_Kind.Unary_Operator;
    node.op = op;
    node.rhs = rhs;

    return node;
}

new_binary_operator_node :: (lhs: *Ast_Node, op: Operator, rhs: *Ast_Node) -> *Ast_Node {

    node: *Binary_Operator_Node = talloc(size_of(Binary_Operator_Node));
    if !node { print("Error!\n" );}

    node.kind = Node_Kind.Binary_Operator;
    node.lhs = lhs;
    node.op = op;
    node.rhs = rhs;

    return node;
}

new_intrinsic_node :: (type: Intrinsic_Type) -> *Ast_Node {

    node: *Intrinsic_Node = talloc(size_of(Intrinsic_Node));
    if !node { print("Error!\n"); }

    node.kind = Node_Kind.Intrinsic;
    node.type = type;

    return node;
}
