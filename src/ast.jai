#scope_export

/* 
    This file declares the Abstract Syntax Tree nodes generated by the parser and updated by the multiple
    passes over the AST.


    On Operator Nodes:

    Operators are rolled up/categorized into either a unary or binary operator node.
    This roll-up reduces the overall number of AST node types but introduces additional computational
    overhead. Specifically, once you encounter a binary operator node in the AST you need to dispatch
    on the operator type whereas if you had a 'Addition' node this extra step would be unnecessary.

    The primary benefit to structuring operators into these categories is that it keeps the number of
    AST node types low. We could do 1-to-1 operator to node type but that would require a bunch of
    new nodes and changes to the parser away from the simple notion of arity for an operator.


    On Scalar Node Types:

    In Grassmann algebra the field of scalars for the Exterior space are considered grade-0 elements.
    Grade-0 objects are *not* represented as basis elements in this application but rather handled separately in their own AST node types.
    The application needs to handle the following cases: 
        1. 3 + 4       = 7          ; sum of individual scalars
        2. 3e1 + 4e1   = 7e1        ; sum of scalar coefficients of basis elements
        3. 3 + a1      = 3 + a1     ; sum of a scalar (value) and a scalar symbol
        4. a1 + b2     = a1 + b2    ; sum of a scalar symbol and another scalar symbol
        5. a1e1 + b2e1 = (a1+b2)e1  ; sum of a scalar symbol coefficients of basis elements

    These examples used addition but it applies to scalar multiplication as well.

    Two scalar node types are introduced to handle all these cases; 'Scalar_Node' and 'Scalar_Expression'.
    Cases (1) and (2) use the basic Scalar_Node type which minimizes wasted memory and is dead simple to calculate addition and multiplication.

    Cases (3), (4) and (5) use the Scalar_Expression node type. This node view creates a list of terms where each term contains a list of scalar
    factors. Obviously the memory usage is much more substantial (especially when the list of terms or factors is sparse) and the resulting calculations
    for addition and multiplication require nested loops. The waste felt substantial enough to split these cases into two unique representations.

*/

Node_Kind :: enum u8 {
    Symbol;
    Basis_Element;
    Scalar;        
    Scalar_Expression;
    Unary_Operator;     // prefix operators
    Binary_Operator;    // infix/postfix operators
    Intrinsic;
}

Ast_Node :: struct {
    kind: Node_Kind;
}

Ast :: struct {
    root: *Ast_Node;
}

Symbol_Node :: struct {
    #as using _kind: Ast_Node;
    name: string;
}

Basis_Element_Node :: struct {
    #as using _kind: Ast_Node;
	
	coefficient: *Ast_Node;	        // scalar or scalar expression
	basis:       *Basis_Element;
}

Scalar_Node :: struct {
    #as using _kind: Ast_Node;
    using scalar: Scalar;
}

Term :: struct {
    multiples: int;
    factors: [Exterior_Space.MAX_DIMENSION] Scalar;
}

Scalar_Expression_Node :: struct {
    #as using _kind: Ast_Node;
    terms: List(Term);
}

Unary_Operator_Node :: struct {
    #as using _kind: Ast_Node;
    op:  Operator;
    rhs: *Ast_Node;
}

Binary_Operator_Node :: struct {
    #as using _kind: Ast_Node;
    lhs: *Ast_Node;
    op:  Operator;
    rhs: *Ast_Node;
}

// Keywords get mapped to intrinsic node types.
// Intrsics are predefined functions/commands that user's can call within an expression.
Intrinsic_Type :: enum u8 {
    Direction;
    Position;
    Basis;
}

Intrinsic_Node :: struct {
    #as using _kind: Ast_Node;
    type: Intrinsic_Type;
}

new_numeric_literal_node :: (value: int) -> *Ast_Node {

    node: *Numeric_Literal_Node = talloc(size_of(Numeric_Literal_Node));
    assert(node != null);

    node.kind = Node_Kind.Numeric_Literal;
    node.value = value;
    return node;
}

new_symbol_node :: (name: string) -> *Ast_Node {

    node: *Symbol_Node = talloc(size_of(Symbol_Node));
    assert(node != null);

    node.kind = Node_Kind.Symbol;
    node.name = name;
    return node;
}

new_basis_element_node :: (coefficient: *Ast_Node, basis_element: *Basis_Element) -> *Ast_Node {

    node: *Basis_Element_Node = talloc(size_of(Basis_Element_Node));
    assert(node != null);

    node.kind        = Node_Kind.Basis_Element;
    node.coefficient = coefficient;
    node.basis       = basis_element;

    return node;
}

new_scalar_node :: (scalar: Scalar) -> *Ast_Node {

    node: *Scalar_Node = talloc(size_of(Scalar_Node));
    assert(node != null);

    node.kind = Node_Kind.Scalar;
    node.scalar = scalar;

    return node;
}

new_scalar_expression_node :: (factor: Scalar) -> *Ast_Node {

    node: *Scalar_Expression_Node = talloc(size_of(Scalar_Expression_Node));
    assert(node != null);

    // Takes a scalar, creates a term with that single factor and returns it.
    term: Term;
    term.multiples = 1;
    
    factors: [..] Scalar;
    terms:   [..] Term;

    array_add(*factors, factor);
    term.factors = factors;

    array_add(*terms, term);

    node.kind  = Node_Kind.Scalar_Expression;
    node.terms = terms;

    return node;
}

new_unary_operator_node :: (op: Operator, rhs: *Ast_Node) -> *Ast_Node {

    node: *Unary_Operator_Node = talloc(size_of(Unary_Operator_Node));
    if !node { print( "Error!\n" ); }

    node.kind = Node_Kind.Unary_Operator;
    node.op = op;
    node.rhs = rhs;

    return node;
}

new_binary_operator_node :: (lhs: *Ast_Node, op: Operator, rhs: *Ast_Node) -> *Ast_Node {

    node: *Binary_Operator_Node = talloc(size_of(Binary_Operator_Node));
    if !node { print("Error!\n" );}

    node.kind = Node_Kind.Binary_Operator;
    node.lhs = lhs;
    node.op = op;
    node.rhs = rhs;

    return node;
}

new_intrinsic_node :: (type: Intrinsic_Type) -> *Ast_Node {

    node: *Intrinsic_Node = talloc(size_of(Intrinsic_Node));
    if !node { print("Error!\n"); }

    node.kind = Node_Kind.Intrinsic;
    node.type = type;

    return node;
}
