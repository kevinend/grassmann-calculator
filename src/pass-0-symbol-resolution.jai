/*
The purpose of symbol resolution is to construct symbol table entries for new symbol nodes and substitute
existing symbol's into the AST. Rather than have the parser try to discern what symbols are,
we take text tokens and literals and create generic 'placeholder' nodes in the AST. This pass over the AST leverages
the symbol table managed by the interpreter and determines whether symbols are basis elements or symbolic scalars
and updates the nodes accordingly. It also substitutes previously computed and stored results of expressions
in place of the symbol nodes generated by the parser.

This pass does *not* validate the semantics of the AST after resolution. The semantic pass occurs after this
step and reports errors in the usage of symbols or operators.
*/

#scope_export

resolve_symbols :: (ast: *Ast, symbol_table: *Symbol_Table) {

    resolve(ast.root, symbol_table);
    return;
}

#scope_file

resolve :: (node: *Ast_Node, symbol_table: *Symbol_Table) -> *Ast_Node {

    // Resolve these nodes using the symbol table.
    if node.kind == .Numeric_Literal {
        return node;
    }
    else
    if node.kind == .Symbol {
        return node;
    }

    // Resolve the children of the operators.
    if node.kind == .Unary_Operator {
        unary_op := cast(*Unary_Operator_Node)node;
        unary_op.rhs = resolve(unary_op.rhs, symbol_table);
    }
    else
    if node.kind == .Binary_Operator {
        binary_op := cast(*Binary_Operator_Node)node;
        binary_op.lhs = resolve(binary_op.lhs, symbol_table);
        binary_op.rhs = resolve(binary_op.rhs, symbol_table);
    }

    return node;

}