/*
The purpose of symbol resolution is to construct symbol table entries for new symbol nodes and substitute
existing symbol's into the AST. Rather than have the parser try to discern what symbols are,
we take text tokens and literals and create generic 'placeholder' nodes in the AST. This pass over the AST leverages
the symbol table managed by the interpreter and determines whether symbols are basis elements or symbolic scalars
and updates the nodes accordingly. It also substitutes previously computed and stored results of expressions
in place of the symbol nodes generated by the parser.

This pass does *not* validate the semantics of the AST after resolution. The semantic pass occurs after this
step and reports errors in the usage of symbols or operators.
*/

#scope_export

resolve_symbols :: (ast: *Ast, symbol_table: *Symbol_Table) {

    ast.root = resolve(ast.root, symbol_table);
    return;
}

#scope_file

resolve :: (node: *Ast_Node, symbol_table: *Symbol_Table) -> *Ast_Node {

    // Resolve these nodes using the symbol table.
    result := node;

    if node.kind == .Numeric_Literal {
        literal        := cast(*Numeric_Literal_Node)node;
        encoded_symbol := encode_scalar("1"); 
        result          = new_scalar_node(literal.value, 0, encoded_symbol);

        // add the symbol to the symbol table for lookup!
    }
    else
    if node.kind == .Symbol {
        symbol := cast(*Symbol_Node)node;
        match, element := check_against_1_elements(symbol_table, symbol.name);
        if match {
            encoded_symbol := encode_scalar("1");
            scalar         := cast(*Scalar_Node)new_scalar_node(1,0,encoded_symbol);

            result := new_basis_element_node(scalar, element);
        }

        // not sure why we wouldn't do that in the lexer or the parser???
        // otherwise you need to resolve this symbol and return it
        // need to determine if it is a basis symbol
        // need to determine if it is a scalar symbol
    }

    // Resolve the children of the operators.
    if node.kind == .Unary_Operator {
        unary_op := cast(*Unary_Operator_Node)node;
        unary_op.rhs = resolve(unary_op.rhs, symbol_table);

        result = unary_op;
    }
    else
    if node.kind == .Binary_Operator {
        binary_op := cast(*Binary_Operator_Node)node;
        binary_op.lhs = resolve(binary_op.lhs, symbol_table);
        binary_op.rhs = resolve(binary_op.rhs, symbol_table);

        result = binary_op;
    }

    return result;
}